// 저번 시간 복습 :: 호이스팅, 컨텍스트, 가비지 컬렉션, 스코프
// 1차 이해

// 1. 호이스팅
// 선언과 할당을 구분해, 선언을 최상위로 끌어올리는 현상

// 1-1. 개념
console.log(num); //undefined, 에러가 아님
var num = 10;
// 에러가 아님 :: 왜? 호이스팅 때문
// 같은 의미
var num;
console.log(num); // 선언이 되고 값 할당 전에 출력됐기 때문
num = 10;

// 1-2. 주의
// (1) **let(const) -> 에러
// error :: cannot access
// var와 달리 값 할당 전까지는 접근이 불가능하기 때문(TDZ) (호이스팅이 진행 된 것은 맞음)

// *TDZ(Temporal Dead Zone) : 일시적 사각 지대 :: 값 할당 전까지는 해당 변수 접근 금지
// let, const는 선언과 초기화 동시 발생 X, 코드 실행 전에 선언을 메모리에 올려두고(호이스팅) 변수 접근은 금지됨
// ( var는 선언과 동시에 undefined로 초기화되어 에러가 나지 않고 undefined을 출력 / let, const 는 아님 )

// (2) **함수의 경우
// 함수 선언문 :: 함수 내용까지 생성 단계에서 통째로 저장됨 -> 에러 X
// ㄴ 코드를 실행하기 전에 함수가 메모리에 먼저 올라가기 때문에, 함수가 선언된 위치보다 앞서서 함수를 호출해도 에러 없이 정상 동작
printName(); //윤희
function printName() {
  console.log("윤희");
}

// 함수 표현식 :: -> 에러
// ㄴ 변수의 호이스팅을 따름
// 1) var printName; 선언만 호이스팅, printName 변수는 undefined로 초기화
// 2) 함수 호출 시점 : 변수에는 함수가 아닌 undefined이 존재
// 3) undefined은 함수가 아니므로 ()로 호출이 불가능 하다는 에러 발생
printName(); //printName is not a function (TypeError)
var printName = () => {
  console.log("윤희");
};
// +. let으로 바꾸면? :: -> 에러
// 1) let printName; 선언만 호이스팅, 초기화 안 됨, 접근불가(TDZ)
// 2) 함수 호출 시점 : 변수에 접근 자체가 불가능 (ReferenceError)
printName(); //Uncaught ReferenceError: printName is not defined
let printName = function () {
  console.log("윤희");
};
// * TypeError / ReferenceError
// TypeError : 변수는 존재, 변수의 값이 올바른 타입이 아니라 연산 수행 불가 (있지만 용도가 다른 것을 찾을 때)
// ReferenceError : 변수가 존재 X 혹은 초기화 X (없는 것을 찾을 때 )

// 1-3. 예제
// 예제 2번 :: 변수와 함수 동시 선언
var num = 5;
console.log(num); //5

function num() {
  return 10;
}

console.log(num); //5
console.log(num()); //에러
// 1)생성 단계 :: 호이스팅에서 함수, 변수 모두 선언 -> var num = undefined, 함수 전체 메모리 저장
// -> 동명으로 변수와 함수 선언이 충돌 -> 변수가 함수를 덮어씀 :: var num = undefined 남음
// 2)실행 단계 :: 순서대로, 변수 5 할당 (출력이 할당보다 뒤에 있으므로) -> 함수는 아무 동작 X 이므로 여전히 5, num()(호출 의미)에서 num은 숫자(5)이므로 호출 불가 에러
// 함수는 아무 동작 X : 이유는 변수에 의해 덮어씌워져 함수의 기능을 잃음

// 예제 3번 :: 변수 재할당
var x = 10;
console.log(x); //10
function test() {
  console.log(x); //undefined
  var x = 5;
  console.log(x); //5
}
test();
console.log(x); //10
// 서로 다른 두 스코프(전역스코프, 함수스코프)에 존재할 때의 호이스팅
// 1) 전역 :: var x; function test() { ... } 호이스팅
// 2) 함수 :: 함수 호출 될 때 / 실행 전, var x;가 **별개** 변수로 호이스팅

// 따라서 undefined 로 초기화 되는 것
// ==> test() 함수를 호출했을 때, 함수 내부의 x 변수가 호이스팅되어 전역 x를 가리고(*변수 shadowing) 따라서 함수 스코프 내부의 x인 undefined 출력
// 마지막 x는 함수가 종료되며 내부의 x 변수도 사라지기 때문에 10만 남음

//////////////////////////////////////////////////////////////////////////////////////

// 2. (전역/함수) 실행 컨텍스트
// 자바스크립트 코드가 실행되는 환경(코드 실행에 영향을 주는 조건/상태)을 제공하는 객체
// 내부적으로 record, outer 등의 객체들로 구성
// *LIFO : Last In, Frist Out : 마지막에 들어간 컨텍스트가 가장 먼저 제거됨

console.log(num1); //메서드
let num1 = 10;

// 2-1. 렉시컬 스코프
// :: 하나의 실행 컨텍스트에서 record enviroment + outer
// ( 05-06 폴더의 이미지 참고 )

// 2-2. record enviroment(환경 레코드) :: 자바스크립트 코드의 선언문을 기록해두는 공간을 가리키는 객체
// (1) 생성 -> (2) 실행 : 두 단계
// 생성 : 변수나 함수와 같은 선언을 메모리에 기록하는 일
// 실행 : 생성 단계에서 기록된 데이터를 바탕으로 코드를 실행(또는 업데이트)하는 일

// 2-3. outer enviroment(외부 렉시컬 환경) :: 자신이 정의가 된 위치에 상위 렉시컬 스코프를 가리킴
// 아우터를 통해서 외부에 있는 식별자를 참조 가능
// *스코프 체인 :: 아우터에 의해서 바깥 렉시컬 스코프를 참조할 수 있는 현상, 연결된 컨텍스트 따라가는 행위

//
let num = 10;
function a() {
  console.log(num);
}
a();

//
var num = 10;
function outer(x) {
  function inner(x) {
    console.log(x + 10);
  }
  inner(x);
}
outer(10);
// 전역 실행 컨텍스트 : num=10; 선언 및 할당 / outer(x){...} 통째로 저장
// 함수 실행 컨텍스트 1 : outer(10) 호출 시점 : num과 별개로 10이 x에 할당 / inner(x){...} 저장
// 함수 실행 컨텍스트 2 : inner(x) 호출 시점 : outer의 10이 inner의 x로 전달, x + 10 실행
// outer 호출 - inner 호출 - inner 종료 - outer 종료 (LIFO)

// 2-4. 콜스택
// 자바스크립트의 코드는 실행 단계에서 컨텍스트라는 박스에 들어가고, 박스들이 쌓이는 곳이 콜스택
// 자바스크립트는 싱글 스레드, 하나의 스레드가 콜스택

/*
1.자바스크립트는 코드 실행 전 "실행 컨텍스트"를 만듬
ㄴ 언제 실행된 컨텍스트냐에 따라서 "전역"과 "함수" 실행 컨텍스트로 나뉨
    ㄴ 전역 실행 컨텍스트(무조건 생성) - 자바스크립트 코드가 함수가 아닌 곳에서 실행되는 환경
    ㄴ 함수 실행 컨텍스트 - 자바스크립트 코드가 함수 내부에서 실행되는 환경

2.컨텍스트 내부에서 record와 outer Enviroment 객체로 나뉨
    ㄴ record Enviroment : 생성과 실행이라는 두 가지 단계로 나뉨

3.만들어진 컨텍스트들은 만들어진 순서대로 콜스택에 담김 (FILO)
    ㄴ 함수 실행 컨텍스트는 항상 전역 실행 컨텍스트 위에 담김
*/

//////////////////////////////////////////////////////////////////////////////////////

// 3. 가비지 컬렉션 (Garbage Collection) (행위) & 가비지 컬렉터 (도구)
// :: 콜스택에서 제거된 (더 이상 참조할 일이 없는) 컨텍스트를 메모리에서 해제함
// 콜스택에 들어있는 컨텍스트가 없을 때 자동 실행 (메모리)
// 콜스택에서 제거된 실행 컨텍스트는 다시 콜스택으로 돌아올 수 없음

//////////////////////////////////////////////////////////////////////////////////////

// 4. 스코프
// - 함수 스코프 :: 함수 안에서만 변수에 접근할 수 있는 유효한 범위
// - 전역 스코프 :: 함수 안이든 밖이든 변수에 접근 할 수 있는 유효한 범위
// - 블록 스코프 :: 블록 범위{} 안에서 접근할 수 있는 유효한 범위
// *스코프 체인 : 연결된 컨텍스트의 따라가는 행위
let num2 = 10;
function a() {
  let num2 = 20;
  console.log(num);
}
a();
// 가능한 이유를 실행 컨테슥트 방면에서 설명 가능해야함
// *변수 쉐도잉 : 동명의 변수 이름으로 인해 가려지는 현상

////////////////////////////////////////////////////////////////////////

// 순서
// 코드 시작: 전역 실행 컨텍스트 생성, 콜스택 추가 -> 함수 호출: 함수 실행 컨텍스트 생성, 콜스택 추가
// -> 생성 단계 -> 실행 단계 -> 함수 종료: 콜스택에서 사라짐 -> 가비지 컬렉샨에 의해 해당 컨텍스트 자동 삭제

// (+)
// 함수 내부에서는 외부의 변수(식별자)를 참조할 수 있다.
// 함수 외부에서는 내부의 변수(식별자)를 참조할 수 앖다.
// 위 내용을 자세하게 풀어내어 이해하는 것
