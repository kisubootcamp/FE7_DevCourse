// 4. for문
// 가장 일반적인 반복문

// (0) 구조
/* for(초기문;조건문;증감문){

} */

// (1) 순서
// 초기문 -> 조건문 -> (참) {} 순서대로 1번 / (거짓) 종료 -> 증감문 -> 처음부터 반복

/* for (let i=1; i<=9; i++){ 
// let 생략 가능 -> 암묵적 선언, 그래도 명시적으로 해주는 것이 좋다. 
 // var i=1 은 ...

 console.log(i)
} 

// (+)
// **let, const는 블록 범위 스코프 -> 영향 범위가 블록 안 ( var는 전역 범위 )    
// **블록 : {} / 스코프 : (변수의 영향) 범위
{
  var num1 = 10;
  let num2 = 11;
}

console.log(num1);
console.log(num2);

/* (2)(반복) 모든 반복문 -> break, continue
continue -> 특정 조건을 건너 뛰게 함
break -> 횟수가 남아도 만나면 반복문을 끝냄
for (let j=1; j<=9; j++){
if (j%2 === 1) continue;
if (j===8) break;
console.log(j);
} */

// (3) 다중 반복문 (사용 지양) :: i, j, k
// 중첩 수 제한 없음, 반복문 종류 제한 없음
// but, 중첩이 많아지면 이해가 까다로움, 가독성 하락, 시간 복잡도 증가 (알고리즘 테스트에서 절대 금지)

/* for (let i = 1; i <= 3; i++) {
  console.log(`i=${i}`);
  for (let j = 1; j <= 3; j++) {
    console.log(`j=${j}`);
  }
} */

// 다른 반복문도 중첩 해보기

// 반복문 n개 중첩될 때마다 값은 n 제곱 만큼 증가 == 선형증가 :: 알고리즘 상 안 좋음

// 1중첩 -> 3 :: o(n)
// 2중첩 -> 3 * 3 = 9 :: o(n2)
// 3중첩 -> 3 * 3 * 3 = 27 :: o(n3)
// 4중첩 -> 3 * 3 * 3 * 3 = 81 :: o(n4)
// O (N * N), Big O

let n = 0;
for (let i = 0; i <= 3; i++) {
  for (let j = 0; j <= 3; j++) {
    for (let k = 0; k <= 3; k++) {
      for (let v = 0; v <= 3; v++) {
        n++;
      }
    }
  }
}
console.log(n);
