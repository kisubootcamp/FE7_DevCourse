##### 생성자 함수

- 생성자 함수로 만들어진 객체를 인스턴스라고 함(=객체)
- 출력했을 때 그냥 객체랑 차이점은 옆에 이름이 써져있는 거 하나밖에 없음
- 함수를 이용해서 객체를 만들어낼 수 있는 방법
- 함수를 호출하는 방법, 예로 함수이름(); 에서 앞에 new를 쓰면 그 이름의 객체가 생성됨

```
const 변수 이름 = new 함수이름();
// 출력값 : 함수이름 {}
```

- 객체를 생성하는 함수들의 이름은 첫 글자를 대문자로 함(구별해주기 위해서)
- 함수 내부에 this를 사용 : this는 객체를 가리키는 지시어
- 따로 찍어낸 객체들은 같은 함수를 바라보고 있어도 서로 독립적
- 매개변수를 주면서 채울수도 있음(유동적으로 할 수 있는 것)
- 생성자 함수 안에 다른 함수를 지정할 수도 있음

##### 프로토타입

- 함수는 함수와 1대1 매칭이 되는 프로토타입이라는 공간을 가지고 있음
- 생성자 함수 뿐만 아니라, 함수 하나당 프로토타입 공간이 있는 것
- 인스턴스 객체는 연결된 함수한테 변수뿐만 아니라 프로토타입을 참조할 수 있는 속성을 물려받음(부모의 프로토타입을 참조할 수 있는 속성)
  - 프로토타입 안에 메서드를 넣어놓고 인스턴스로 그 함수를 호출해도 호출이 되는 이유가 부모한테 참조할 수 있는 경로를 받기 때문에
  - 이렇게 생성자 함수랑 연결되어 있는 걸 프로토타입 체인이라고 하고, 프로토타입까지 가서 메서드를 찾는 행위를 프로토타입 체이닝이라고 함
    - 프로토타입 체인 : 연결되어 있는 것
    - 프로토타입 체이닝 : 연결되어 있는 통로로 메서드를 찾으러 가는 행위
  ```
  Car.prototype.drive = this.drive = function () {
  return `${this.make}, ${this.model}, ${this.year}`;
    };
    car1.drive() 해도 출력이 그대로 나오는 것
  ```

##### constructor(콘스트럭터)

- 프로토타입 쪽에서 함수 쪽으로 참조할 수 있게 해주는 것
- constructor를 가지고 있는 애들은 대부분 프로토타입 객체임(인스턴스.언더바언더바proto언더바언더바 : 이걸로 히든을 참조할 수 있음)

##### this

- this는 함수를 호출한 객체를 가리킨다.
- 화살표 함수의 this, 일반 함수의 this

```
function main() {
  console.log(this);
}

const obj = {
  name: "kim",
  main: main,
  smallObj: {
    name: "small",
    main: main,
  },
};

obj.main(); //여기서는 자신(함수)을 호출한 obj(객체)를 가리킴
obj.smallObj.main(); //여기서는 자신(함수)을 호출한 smallObj(객체)를 가리킴
```

- 함수.bind : this가 가리키는 객체를 강제로 고정시킬 수 있음
  //원래는 위 호출한 객체가 나와야 하는데, bind를 추가해서 뒤에 객체를 넣으면 this가 기리키는 객체를 강제로 고정한다.

```
const main = function main() {
  console.log(this);
}.bind({ name: "sucoding" });

main();
```

- 화살표 함수
  - 화살표 함수는 내부적으로 this가 없다
  - 자신이 속해 있는 컨텍스트의 this를 빌려온다
  - 자신의 위치에 있는 곳에서 this를 빌려오는 거라서, 자신의 위치의 상위 렉시컬 환경에서, 지금 전역 콘텍스트(=window)에 있어서 그걸 가져옴
  - this를 쓰는 곳에서는 화살표 함수를 안 쓰는 것이 국룰

##### 상속

- Object.create(객체.prototype) 이걸로 매개변수에 있는 객체 프로토타입을 참조해 새로운 객체를 만들면서 상속을 가능하게 함
