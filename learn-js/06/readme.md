### 일급 객체(함수는 일급 객체)

- 일급 객체는 객체의 하위 느낌

##### 일급 객체의 조건

1. 변수나 데이터 구조(배열, 객체)에 담을 수 있다
2. 함수의 인자로 전달할 수 있어야 한다
3. 함수의 반환 값으로 사용할 수 있어야 한다
4. 런타임에 생성할 수 있어야 한다
5. 프로퍼티(속성)을 가질 수 있어야 한다.

##### 콜스택?(콜스택 + 실행컨텍스트)

- 모든 자바스크립트는 콜스택이라는 자료구조에서 실행이 된다
- 자바스크립트는 First In, Last out임
- 실행컨텍스트 : 자바스크립트 코드가 실행되는 환경
  - 콜스택 안에 실행 컨테스트를 넣고 그 안에 코드를 넣고 실행하는 느낌
- 전역 실행컨텍스트(환경) : 자바스크립트 코드가 함수가 아닌 곳에서 실행되는 환경
  - 전역 실행 컨텍스트 내에는 variable, lexical, outer enviroment가 있다
  - ES6부터는 variable, lexical enviroment을 record enviroment로 통합적으로 부른다
  - record enviroment 는 모든 걸 기록하는 것이라고 생각
    - 생성 단계(var num), 모든 변수와 함수 선언 같은 것들이 기록
      - let이나 const는 일시적 사각 지대(TDZ)가 생겨서 에러나 나오는 경우가 있음
    - 실행 단계, 생성 단계에서 기록된 정보를 바탕으로 코드를 실행
    - 호이스팅이 되는 게 먼저 생성 단계에서 record에 저장을 하고 그 후에 실행 단계가 오면서 값을 할당하게 되어서 그렇게 된다고 이해해도 됨
- 함수 실행컨텍스트 = 자바스크립트 코드가 함수 내부에서 실행되는 환경
  - 함수가 실행되면 함수 실행컨텍스트가 하나 더 생김
  - 만약 함수 안에 함수 호출이 또 있으면, 첫 번째 함수에서 선언만 되고 또 새로운 함수 컨텍스트가 생기는 것
- 다 실행된 후에는 콜스택에서 실행컨텍스트가 제거된다.
- 매개변수를 가지고 함수 실행컨텍스트를 만들면, 그 함수 실행컨텍스트 생성단계에서 자동으로 그 매개변수가 만들어진다.

##### 가비지 컬렉터와 가비지 컬렉션

- 가비지 컬렉터 : 쓰지 않는 메모리를 자동으로 회수하는 것(도구)
- 가비지 컬렉션 : 컬렉터가 메모리를 회수하느 과정(과정)
- 가비지 컬렉터는 어떤 걸 기준으로 메모리를 회수할까?
  - 그건 콜스택에서 실행컨텍스트가 제거될 때이다. 제거된 실행컨텍스트는 다시 실행할 수 없기 때문에, 가비지 컬렉터가 회수를 한다

##### 함수 내, 외에 있는 변수가 어떻게 다른가

- 전역으로 변수를 만들면 전역 실행컨텍스트에 만들어지고, 함수를 호출하면 함수 컨텍스트가 만들어지고 그 함수 내에서 새로운 변수를 선언, 할당하면 그 함수 실행컨텍스트에 만들어져서 const여도 새롭게 선언이 되는 것
  - 한 마디로 실행컨텍스트가 다른 곳에서 만들어져서 const여도 재선언이 가능한 것
  - 이 const가 선언이 다시 되는 건 같은 컨텍스트 안에서만 유효하다는 뜻
- 그럼 만약 함수에서 호출한 변수가 전역 컨텍스트에만 있다면? 이때는 outer enviroment가 나오는 것

###### record enviroment + outer enviroment = 렉시컬 환경

- outer enviroment는 렉시컬 환경의 연결통로를 해줌
  - 스코프체인 : outer로 상위 스코프로 찾아가는 행위 자체를 스코프체인이라고 함(하지만 구성요소는 아니고, 행위 그 자체이다)
  - 일방통행임, 위에서 아래로 내려갈 수만 있음( = 자신의 상위 렉시컬 환경에 연결하는 게 outer의 역할)
- 그럼 위 상황을 다시 말할 때, 내가 실행단계에서 호출하려는 메모리(변수가 포함된다)가 없으면, outer 객체로 연결되어져 있는 상위 렉시컬 스코프로 그 변수를 찾아서 올라간다. 상위에 그 변수에 대한 흔적이 남아 있으면 쓰는 것
- 그럼 반대로 상위 record에 있는 메모리에 할당되지는 않았지만, 하위에는 있는 변수인데 상위 실행단계에서 없는 변수이면, 선언되지 않은 변수라고 나온다
  - 왜 상위에서 하위 outer로 못가는가? javascript는 싱글스레드이기 때문에, 만약 콜스택 위에 실행컨텍스트가 하나 생기면 그 밑에 깔린 컨텍스트는 실행되지 않음, 그러면 만약 함수를 다 실행하고 그 함수 실행컨텍스트가 제외되면, 그 할당된 메모리(변수)도 사라지기 때문에 전역 실행컨텍스트를 실행하며 그 위 함수 실행컨텍스트를 outer로 참조하지 못 하는것
- 변수 쉐도잉 : 가까운 곳에 있는 변수를 참조할 수 있어서, 상위에 있는 변수가 가려지는 것
- 함수가 정의된 위치에 따라 다른 함수에서 함수를 호출했어도, 함수가 정의된 곳이 전역컨텍스트 쪽에 있으면 전역컨텍스트에 선언된 변수를 호출한다.

##### 스코프

- 함수 스코프 : 함수 안에서만 변수에 접근할 수 있는 유효한 범위
- 전역 스코프 : 함수 안이든 밖이든 변수에 접근할 수 있는 유효한 범위
- 블록 스코프 : 블록 안에서 접근할 수 있는 유효한 범위 {}
