# 연습문제 ++

## 1. 문자열 압축

문자열이 주어졌을 때, 연속된 동일한 문자를 하나의 문자와 그 문자의 개수로 압축해서 반환하는 함수를 만들어주세요.

### 입/출력 예시

```tsx
const i = "aaabbbccc";
const o = "a3b3c3";

const i2 = "aabbaa";
const o2 = "a2b2a2";

const i3 = "abbbffd";
const o3 = "a1b3f2d1";

const i4 = "aabaa";
const o4 = "a2b1a2"; // a4b1
```

**답**:

```jsx
function charCounter(string) {
  let charCount = {};
  let result = "";

  for (let i = 0; i < string.length; i++) {
    const current = string[i];
    charCount[current] === undefined
      ? (charCount[current] = 1)
      : charCount[current]++;
  }

  for (const key in charCount) {
    result += `${key}${charCount[key]}`;
  }

  return result;
}

console.log(charCounter("aaabbbccc"));
console.log(charCounter("aabbaa"));
console.log(charCounter("abbbffd"));
console.log(charCounter("aabaa"));
```

## **2. 팰린드롬 확인하기(쉬운 버전)**

주어진 문자열이 팰린드롬인지 확인하는 함수를 작성하세요. 팰린드롬이란 앞에서부터 읽으나 뒤에서부터 읽으나 같은 문자열을 말합니다. 대소문자를 구분하지 않으며, 매개변수는 항상 공백 없이 소문자 알파뱃만 넘어온다고 가정합니다.

### 입출력 예시

```jsx
console.log(isPalindrome("racecar")); // true
console.log(isPalindrome("hello")); // false
console.log(isPalindrome("level")); // true
console.log(isPalindrome("world")); // false
```

**답**:

```jsx
function isPalindrome(str) {
  let len = str.length;
  let reversed = "";

  for (let i = 1; i <= len; i++) {
    reversed += str[len - i];
  }

  if (str === reversed) return true;
  else return false;
}

console.log(isPalindrome("racecar")); // true
console.log(isPalindrome("hello")); // false
console.log(isPalindrome("level")); // true
console.log(isPalindrome("world")); // false
```

## 3. 펠린드롬 확인하기 (어려운 버전)

주어진 문자열이 팰린드롬인지 확인하는 함수를 작성하세요. 팰린드롬이란 앞에서부터 읽으나 뒤에서부터 읽으나 같은 문자열을 말합니다. 대소문자를 구분하지 않으며, 알파벳 이외의 문자는 무시합니다.

### 입출력

```jsx
console.log(isPalindromeSentence("A man, a plan, a canal, Panama!")); // true
console.log(isPalindromeSentence("Was it a car or a cat I saw?")); // true
console.log(isPalindromeSentence("Hello, world!")); // false
console.log(isPalindromeSentence("No 'x' in Nixon")); // true
```

**답**:

```jsx
function isPalindromeSentence(str) {
  const regex = /[a-z]/;
  let filteredStr = [...str.toLowerCase()]
    .filter((char) => {
      if (regex.test(char)) return true;
      else false;
    })
    .join("");
  let len = filteredStr.length;
  let reversed = "";

  for (let i = 1; i <= len; i++) {
    reversed += filteredStr[len - i];
  }

  if (filteredStr === reversed) return true;
  else return false;
}

console.log(isPalindromeSentence("A man, a plan, a canal, Panama!")); // true
console.log(isPalindromeSentence("Was it a car or a cat I saw?")); // true
console.log(isPalindromeSentence("Hello, world!")); // false
console.log(isPalindromeSentence("No 'x' in Nixon")); // true
```

## 4. 최대 공약수(GCD)

두 정수를 전달 받아서 최대 공약수를 구하는 함수를 구현하세요.

최대 공약수는 공통된 약수 중 가장 큰 수를 의미합니다.

예)

      12 - 1, 2, 3, 4, 6 12
      18 - 1, 2, 3, 6, 9, 18

약수 : 1, 2, 3, 6

최대 공약수 6

// 유클리드 호제법

### 입출력

```jsx
gcd(56, 98); // 14
gcd(101, 10); // 1
gcd(15, 5); // 5
gcd(100, 75); // 25
gcd(18, 24); // 6
```

**답**:

```jsx
function bubbleSort(arr) {
  let newArr = [...arr];
  let temp = 0;

  for (let i = 0; i < newArr.length - 1; i++) {
    for (let j = 1; j < newArr.length; j++) {
      if (newArr[j] < newArr[j - 1]) {
        temp = newArr[j - 1];
        newArr[j - 1] = newArr[j];
        newArr[j] = temp;
      }
    }
  }

  return newArr;
}

function getCd(num) {
  let cd = [];

  for (let i = 1; i < num; i++) {
    for (let j = 2; j <= num; j++) {
      if (i === j) break;
      if (i * j === num) {
        cd = [...cd, i, j];
        break;
      }
    }
  }

  return bubbleSort(cd);
}

function gcd(num1, num2) {
  const cd1 = getCd(num1);
  const cd2 = getCd(num2);
  let cdsCount = {};
  let cds = [];

  for (let i = 0; i < cd1.length; i++) {
    const current = cd1[i];
    cdsCount[current] === undefined
      ? (cdsCount[current] = 1)
      : cdsCount[current]++;
  }

  for (let i = 0; i < cd2.length; i++) {
    const current = cd2[i];
    cdsCount[current] === undefined
      ? (cdsCount[current] = 1)
      : cdsCount[current]++;
  }

  for (const key in cdsCount) {
    if (cdsCount[key] === 2) cds.push(key);
  }

  let gcd = 0;

  for (let i = 0; i < cds.length; i++) {
    const current = Number(cds[i]);
    if (current >= gcd) gcd = current;
  }

  return gcd;
}

console.log(gcd(56, 98)); // 14
console.log(gcd(101, 10)); // 1
console.log(gcd(15, 5)); // 5
console.log(gcd(100, 75)); // 25
console.log(gcd(18, 24)); // 6
```

## 5. 배열 정렬(버블 정렬)

주어진 배열을 오름차순으로 정렬하는 함수를 작성하시오.

```jsx
console.log(bubbleSort([5, 3, 8, 1, 2])); // [1, 2, 3, 5, 8]
```

**답**:

```jsx
function bubbleSort(arr) {
  let newArr = [...arr];
  let temp = 0;

  for (let i = 0; i < newArr.length - 1; i++) {
    for (let j = 1; j < newArr.length; j++) {
      if (newArr[j] < newArr[j - 1]) {
        temp = newArr[j - 1];
        newArr[j - 1] = newArr[j];
        newArr[j] = temp;
      }
    }
  }

  return newArr;
}

console.log(bubbleSort([5, 3, 8, 1, 2])); // [1, 2, 3, 5, 8]
```
